
/** 
 * f_ module
 * @desc
 * Waterfall async tasks using a simple API
 *
 * Need to add the following to the 'parent' prototype
 * flow  {array}     Function names to flow
 * reset {function}  Function that knows which properties
 *                   to reset from the 'parent'
 * retry {function}  Inits a retry, calls reset and emits data
 * next  {function}  Allows for: this.next(); syntax in flow parent class
 */


var Ezlog = require('ezlog'),
		log = new Ezlog({
			pref: { t: '[f_]', c: 'magenta' }
		});

/**
 * f_ functions namespace, containing all required function
 * to add to the parent class
 */
var ff = {

	reset: function (){

		this.next_i = 0;

		for(var i=0, obj; i<this.toReset.length; i+=1){
			obj = this.toReset[i];

			var val; 
			for(var key in obj){
				val = obj[key];
				if(this[key]) this[key] = val;
			}
		}

	},
	/** Perhaps a retryAtAndSave(['d']) function ? */
	retry: function (err){

		if(this.next_tries >= this.next_maxTries)
			return this.f_abort('Maximum retries exceeded');

		if(typeof err === 'string')
			err = '@' + this.currentFn + '  ' + err;

		if(err)
			this.errs.push(err);

		this.next_tries += 1;
		this.reset();

		log('-- -- --')
		log('Retry err: ' + err);
		log('-- ' + this.f_desc + ': Try ' + this.next_tries + ' of max '
			+ this.next_maxTries + ' --');

		this.next();

		if(this.onRetry) this.onRetry();
	},

	next: function (){

		if(this.next_i === 0) log('starting task: ' + this.f_desc);

		if(this.next_i === this.functionFlow.length)
			return this.f_finish();

		var fn = this.functionFlow[this.next_i];

		this.currentFn = fn;

		if(this[fn] && typeof this[fn] === 'function'){
			this.next_i += 1;

			if(this.onNext) this.onNext({ fn:fn });

			this[fn]();
		}
		else return this.f_abort('no next function for flow');

	},

	f_abort: function (err){
		log('f_abort: ' + this.f_desc + ', errs stack below' , err);

		if(err) this.errs.push(err);

		if(this.onAbort) this.onAbort(err);
	},

	f_finish: function (){
		log('f_ task complete: '+ this.f_desc +'\n');
		if(this.onFinish) this.onFinish();
	}

};


/**
 * f_ properties
 */
var fp = {
	next_i: 0,
	next_tries: 1,
	next_maxTries: 15,
};


/**
 * Main function that augments all props and vals to Class
 *
 * @arg    par {Class}  parent class function to run flow on
 * @return par {Class}  augmented  ^
 */
function augment(par, desc){

	if(!par) throw 'need parent object class';

	if(typeof par !== 'function') throw 'typeof parent ! func';
	
	if(par.f_) throw 'not going to overwrite par.f_'
	
	for(var fn in ff){ // function name
		if(par[fn]) throw 'not going to overwrite par[fn] ' + fn;
		par.prototype[fn] = ff[fn];
	}

	for(var pn in fp){ // property name
		if(par[pn]) throw 'not going to overwrite par[pn] ' + fn;
		par.prototype[pn] = fp[pn];
	}

	desc = desc || '';

	par.prototype.f_desc = desc;

	return par;

}

module.exports = {
	augment: augment
};